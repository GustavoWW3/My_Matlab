1c1
< function [bound_ingrid,Nb] = compute_boundary(coord,bound)
---
> function [bound_ingrid,Nb] = compute_boundary(coord,bound,icoords)
3,62c3,66
< % -------------------------------------------------------------------------
< %|                                                                        |
< %|                    +----------------------------+                      |
< %|                    | GRIDGEN          NOAA/NCEP |                      |
< %|                    |                            |                      |
< %|                    | Last Update :  23-Oct-2012 |                      |
< %|                    +----------------------------+                      |
< %|                     Distributed with WAVEWATCH III                     |
< %|                                                                        |
< %|                 Copyright 2009 National Weather Service (NWS),         |
< %|  National Oceanic and Atmospheric Administration.  All rights reserved.|
< %|                                                                        |
< %| DESCRIPTION                                                            |
< %| Computes the shoreline polygons from the GSHHS database that lie within| 
< %| the grid domain, properly accounting for polygons that cross the domain| 
< %| The routine has been designed to work with coastal polygons only but   |
< %| that can be changed by changing the flag bound(i).flag in the code. See|
< %| GSHHS documentation for the meaning of the different flags             |
< %|                                                                        |
< %| [bound_ingrid,Nb] = compute_boundary(coord,bound)                      |
< %|                                                                        |
< %| INPUT                                                                  |
< %|   coord : An array defining the corner points of the grid              |
< %|           coord(1) = Lattitude (y) of lower left hand corner           |
< %|           coord(2) = Longitude (x) of lower left hand corner           |
< %|           coord(3) = Lattitude (y) of upper right hand corner          |
< %|           coord(4) = Longitude (x) of upper right hand corner          |
< %|   bound : A data structure array of the basic polygons (The GSHHS      |
< %|           polygons are stored as mat files with several different      | 
< %|           resolutions and the user should ensure that the files have   |
< %|           been loaded before using this routine).                      |
< %|                                                                        |
< %|           The different available files are --                         |
< %|             coastal_bound_ful.mat    -- Full resolution                |
< %|                                         (188606 polygons)              |
< %|		       coastal_bound_high.mat   -- High resolution        |
< %|                                         (0.2 km; 153539 polygons)      |
< %|		       coastal_bound_inter.mat  -- Intermediate resolution|
< %|                                         (1 km; 41523 polygons)         |
< %|		       coastal_bound_low.mat    -- Low resolution         |
< %|                                         (5 km; 10769 polygons)         |
< %|		       coastal_bound_coarse.mat -- Coarse resolution      |
< %|                                         (25 km; 1866 polygons)         |
< %|                                                                        |
< %|	    Alternatively, a separate list of user defined polygons can   |
< %|          be generated having the same fields as bound. One such list is|
< %|	    "optional_coastal_polygons.mat" which is also distributed with|
< %|          reference data. This is an ever growing list of water bodies  |
< %|          that see very little wave action and for most practical       | 
< %|          purposes can be masked out as land.                           |
< %|                                                                        | 
< %|          See also optional_bound.m which shows how the optional coastal|
< %|          polygons are used                                             |
< %|                                                                        | 
< %| OUTPUT                                                                 |
< %|  bound_ingrid : Subset data structure array of polygons that lie inside|
< %|                 the grid                                               |
< %|  Nb           : Total number of polygons found that lie inside the grid|
< %|                                                                        |
< % -------------------------------------------------------------------------
---
> % -------------------------------------------------------------------------------------
> %|                                                                                     |
> %|                          +----------------------------+                             |
> %|                          | GRIDGEN          NOAA/NCEP |                             |
> %|                          |      Arun Chawla           |                             |
> %|                          |  Andre van der Westhuysen  |                             |
> %|                          |                            |                             |
> %|                          | Last Update :  20-Aug-2010 |                             |
> %|                          +----------------------------+                             |
> %|                                    Arun.Chawla@noaa.gov                             |
> %|                         Andre.VanderWesthuysen@noaa.gov                             |
> %|                          Distributed with WAVEWATCH III                             |
> %|                                                                                     |
> %|                     Copyright 2009 National Weather Service (NWS),                  |
> %|       National Oceanic and Atmospheric Administration.  All rights reserved.        |
> %|                                                                                     |
> %| DESCRIPTION                                                                         |
> %| Computes the shoreline polygons from the GSHHS database that lie within the         |
> %| grid domain, properly accounting for polygons that cross the domain. The routine    |
> %| has been designed to work with coastal polygons only but that can be changed by     | 
> %| changing the flag bound(i).flag in the code. See GSHHS documentation for the        |
> %| meaning of the different flags                                                      |
> %|                                                                                     |
> %| [bound_ingrid,Nb] = compute_boundary(coord,bound)                                   |
> %|                                                                                     |
> %| INPUT                                                                               |
> %|   coord : An array defining the corner points of the grid                           |
> %|           coord(1) = Lattitude (y) of lower left hand corner                        |
> %|           coord(2) = Longitude (x) of lower left hand corner                        |
> %|           coord(3) = Lattitude (y) of upper right hand corner                       |
> %|           coord(4) = Longitude (x) of upper right hand corner                       |
> %|   bound : A data structure array of the basic polygons (The GSHHS polygons are      |
> %|           stored as mat files with several different resolutions and the user       | 
> %|           should ensure that the files have been loaded before using this routine). |
> %|                                                                                     |
> %|           The different available files are --                                      |
> %|              coastal_bound_ful.mat    -- Full resolution         (188606 polygons)  |
> %|		coastal_bound_high.mat   -- High resolution (0.2 km; 153539 polygons)  |
> %|		coastal_bound_inter.mat  -- Intermediate resolution                    |
> %|                                                             (1 km; 41523 polygons)  |
> %|		coastal_bound_low.mat    -- Low resolution     (5 km; 10769 polygons)  |
> %|		coastal_bound_coarse.mat -- Coarse resolution  (25 km; 1866 polygons)  |
> %|                                                                                     |
> %|	    Loading any of these files would create a data structure array of the      |
> %|          GSHHS polygons called "bound" and the user can use any of the above        |
> %|	    Alternatively, a separate list of user defined polygons can also be        |
> %|          generated having the same fields as bound. One such list is                |
> %|	    "optional_coastal_polygons.mat" which is also distributed with the         |
> %|          reference data. This is an ever growing list of water bodies that see      |
> %|          very little wave action and for most practical purposes can be masked out  |
> %|          as land.                                                                   |
> %|                                                                                     | 
> %|          See also optional_bound.m which shows how the optional coastal polygons    |
> %|          are used                                                                   |
> %|   icoords : Coordinate system representation for longitude data                     |
> %|               Options are --                                                        |
> %|                  0 --> Longitudes range from -180 to 180                            |
> %|                  1 --> Longitudes range from 0 to 360                               |
> %|                                                                                     | 
> %| OUTPUT                                                                              |
> %|  bound_ingrid : Subset data structure array of polygons that lie inside the grid    |
> %|  Nb           : Total number of polygons found that lie inside the grid             |
> %|                                                                                     |
> % -------------------------------------------------------------------------------------
71,72c75
< %@@@ Minimum distance between points (to avoid round off errors from points
< %@@@ too close to each other)
---
> %@@@ Minimum distance between points (to avoid round off errors from points too close to each other)
76,83c79
< %@@@ Maximum distance between points. This is being defined so that we do
< %@@@ not have large gaps between subsequent points of the final boundary
< %@@@ polygon
< 
< MAX_SEG_LENGTH = 0.25;
< 
< %@@@ Polygon defining the bounding grid. Bounding grid is defined in the 
< %@@@ counter clockwise direction
---
> %@@@ Polygon defining the bounding grid. Bounding grid is defined in the counter clockwise direction
111a108
> %@@@ Convert base data to specified longitude range
112a110,126
>       if (icoords == 0)
>           for i = 1:N
>               loc = find(bound(i).x > 180);
>               bound(i).x(loc) = bound(i).x(loc) - 360;
>               bound(i).west = min(bound(i).x);
>               bound(i).east = max(bound(i).x);
>               clear loc;
>           end;
>       elseif (icoords == 1)
>           for i = 1:N
>               loc = find(bound(i).x < 0);
>               bound(i).x(loc) = bound(i).x(loc) + 360;
>               bound(i).west = min(bound(i).x);
>               bound(i).east = max(bound(i).x);
>               clear loc;
>           end;
>       end;
118,120c132,133
<     %@@@ Limit boundaries to coastal type only. This flag needs to be 
<     %@@@ changed if interested in other boundaries. See GSHHS documentation 
<     %@@@ for boundary type flags
---
>     %@@@ Limit boundaries to coastal type only. This flag needs to be changed if 
>     %@@@ interested in other boundaries. See GSHHS documentation for boundary type flags
132c145
< 
---
>         
135,136c148,149
<         if (bound(i).west >= lon_start && bound(i).east <= lon_end && ...
<                bound(i).south >= lat_start && bound(i).north <= lat_end)
---
>         if (bound(i).west >= lon_start & bound(i).east <= lon_end & ...
>                bound(i).south >= lat_start & bound(i).north <= lat_end)
150,151c163
<                 %@@@ Determine the points of the boundary that are 
<                 %@@@ inside/on/outside the bounding box
---
>                 %@@@ Determine the points of the boundary that are inside/on/outside the bounding box
158,159c170
<                 %@@@ Ignore points that lie on the domain but neighboring 
<                 %@@@ points do not
---
>                 %@@@ Ignore points that lie on the domain but neighboring points do not
172c183
<                     if (in_points(p1) == 0 && in_points(p2) == 0)
---
>                     if (in_points(p1) == 0 & in_points(p2) == 0)
175,197d185
<                 end;                
< 
<                 %@@@ Points of domain in the boundary
<                 
<                 domain_inb = inpolygon(px,py,bound(i).x,bound(i).y);
<                 loc_t = find(domain_inb == 1);
<                 domain_inb_lth = length(loc_t);
< 
<                 if (isempty(loc1))
<                     if (domain_inb_lth == length(px))
<                         bound_ingrid(in_coord).x = px;
<                         bound_ingrid(in_coord).y = py; 
<                         bound_ingrid(in_coord).n = length(px);
<                         bound_ingrid(in_coord).west = lon_start;
<                         bound_ingrid(in_coord).east = lon_end;
<                         bound_ingrid(in_coord).north = lat_end;
<                         bound_ingrid(in_coord).south = lat_start;
<                         bound_ingrid(in_coord).height = lon_end - lon_start;
<                         bound_ingrid(in_coord).width = lat_end - lat_start;
<                         bound_ingrid(in_coord).level = 1;
<                         in_coord = in_coord + 1;
<                     end;
<                     clear loc_t domain_inb;
206,207c194,195
<                     %@@@ Flag the points where the boundary moves from in 
<                     %@@@ to out of the domain as well as out to in
---
>                     %@@@ Flag the points where the boundary moves from in to out of the domain
>                     %@@@ as well as out to in
216c204
<                         if (in_points(j) > 0 && in_points(j+1) == 0)
---
>                         if (in_points(j) > 0 & in_points(j+1) == 0)
220c208
<                         if (in_points(j) == 0 && in_points(j+1) > 0)
---
>                         if (in_points(j) == 0 & in_points(j+1) > 0)
233,234c221
<                     %@@@ Crossing points are oriented to make sure we start 
<                     %@@@ from out to in
---
>                     %@@@ Crossing points are oriented to make sure we start from out to in
247,249c234,242
<                                     
<                     clear in2out_gridbox in2out_gridboxdist in2out_xcross in2out_ycross;
<                     clear out2in_gridbox out2in_gridboxdist out2in_xcross out2in_ycross;
---
> 
>                     in2out_gridbox = [];
>                     out2in_gridbox = [];
>                     in2out_gridboxdist = [];
>                     out2in_gridboxdist = [];
>                     in2out_xcross = [];
>                     out2in_xcross = [];
>                     in2out_ycross = [];
>                     out2in_ycross = [];
267c260
<                                 else
---
> 				else
273,274c266
<                                    in2out_gridboxdist(j) = k-1 + ...
<                                        sqrt((px(k)-x1)^2+(py(k)-y1)^2)/box_length(k);
---
>                                    in2out_gridboxdist(j) = k-1 + sqrt((px(k)-x1)^2+(py(k)-y1)^2)/box_length(k);
283c275
<                         else
---
> 			else
330,331c322
<                             in2out_gridboxdist(j) = k-1 + ...
<                                 sqrt((px(k)-x)^2+(py(k)-y)^2)/box_length(k);
---
>                             in2out_gridboxdist(j) = k-1 + sqrt((px(k)-x)^2+(py(k)-y)^2)/box_length(k);
335c326
<                         if (on_points(out2in(j)+1) == 1)
---
>                         if(on_points(out2in(j)+1) == 1)
348,349c339
<                                    out2in_gridboxdist(j) = k-1 + ...
<                                        sqrt((px(k)-x1)^2+(py(k)-y1)^2)/box_length(k);
---
>                                    out2in_gridboxdist(j) = k-1 + sqrt((px(k)-x1)^2+(py(k)-y1)^2)/box_length(k);
357c347
<                         else
---
> 			else
402,403c392
<                             out2in_gridboxdist(j) = k-1 + ...
<                                 sqrt((px(k)-x)^2+(py(k)-y)^2)/box_length(k);
---
>                             out2in_gridboxdist(j) = k-1 + sqrt((px(k)-x)^2+(py(k)-y)^2)/box_length(k);
414,445d402
<                         crnr_acc = 1 - domain_inb;
<      
<                         while(~isempty(find(subseg_acc == 0,1)))
<                             
<                             %@@@ Starting from the closest unaccounted
<                             %@@@ segment
<                             
<                             min_pos = 0;
<                             min_val = 4;
<                             for j = 1:in2out_count
<                                 if (subseg_acc(j) == 0)
<                                     if (out2in_gridboxdist(j) <= min_val)
<                                         min_val = out2in_gridboxdist(j);
<                                         min_pos = j;
<                                     end;
<                                 end;
<                             end;
<                             
<                             j = min_pos;   
<                             
<                             bound_ingrid(in_coord).x = [];
<                             bound_ingrid(in_coord).y = [];
<                             bound_ingrid(in_coord).n = 0;
<                             bound_ingrid(in_coord).east = 0;
<                             bound_ingrid(in_coord).west = 0;
<                             bound_ingrid(in_coord).north = 0;
<                             bound_ingrid(in_coord).south = 0;
<                             bound_ingrid(in_coord).height = 0;
<                             bound_ingrid(in_coord).width = 0;
<                             
<                             bound_x = [];
<                             bound_y = [];
447,450c404
<                             if (~isnan(out2in_xcross(j)))
<                                 bound_x = out2in_xcross(j);
<                                 bound_y = out2in_ycross(j);
<                             end;
---
>                         %@@@ Keep looping till all intersection points accounted for
452,460c406
<                             if ((out2in(j)+1) <= in2out(j))
<                                 bound_x = [bound_x;bound(i).x((out2in(j)+1):in2out(j))];
<                                 bound_y = [bound_y;bound(i).y((out2in(j)+1):in2out(j))];                       
<                             else                               
<                                 bound_x = [bound_x;bound(i).x((out2in(j)+1):n);...
<                                                   bound(i).x(2:in2out(j))];
<                                 bound_y = [bound_y;bound(i).y((out2in(j)+1):n);...
<                                                   bound(i).y(2:in2out(j))];                              
<                             end;
---
>                         while(~isempty(find(subseg_acc == 0)))
462,464c408,416
<                             if (~isnan(in2out_xcross(j)))
<                                 bound_x = [bound_x;in2out_xcross(j)];
<                                 bound_y = [bound_y;in2out_ycross(j)];
---
>                             j=1;
>                             while(subseg_acc(j) == 1)
>                                 j=j+1;
>                                 if (j > in2out_count)
>                                     j=1;
>                                 end;
>                                 if (isempty(find(subseg_acc == 0)))
>                                     break;
>                                 end;
466,477d417
< 
<                             close_bound=0; %@@@ Flag initializing close boundary
<                                 
<                             starting_edge = out2in_gridbox(j);
<                             ending_edge = in2out_gridbox(j);
<                                 
<                             subseg_acc(j) = 1;
<                             
<                             %@@@ Find the next closest segment going
<                             %@@@ anti-clockwise
<                             
<                             seg_index = j;                           
478a419,464
>                             %@@@ Starting a new boundary from the first unaccounted for intersection
>                             %@@@ point. Boundary polygon is constructed by starting from the first time
>                             %@@@ the original polygon intersects the domain coming in and including all
>                             %@@@ the internal points and the intersection point from where it goes out again.
> 
>                             if (subseg_acc(j) == 0)
>                         
>                                 bound_ingrid(in_coord).x = [];
>                                 bound_ingrid(in_coord).y = [];
>                                 bound_ingrid(in_coord).n = 0;
>                                 bound_ingrid(in_coord).east = 0;
>                                 bound_ingrid(in_coord).west = 0;
>                                 bound_ingrid(in_coord).north = 0;
>                                 bound_ingrid(in_coord).south = 0;
>                                 bound_ingrid(in_coord).height = 0;
>                                 bound_ingrid(in_coord).width = 0;
> 
>                                 if (~isnan(out2in_xcross(j)))
>                                     bound_ingrid(in_coord).x = out2in_xcross(j);
>                                     bound_ingrid(in_coord).y = out2in_ycross(j);
>                                 end;
> 
>                                 if ((out2in(j)+1) <= in2out(j))
>                                     bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;...
>                                                           bound(i).x((out2in(j)+1):in2out(j))];
>                                     bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;...
>                                                           bound(i).y((out2in(j)+1):in2out(j))];                       
>                                 else                               
>                                     bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;...
>                                                           bound(i).x((out2in(j)+1):n);...
>                                                           bound(i).x(2:in2out(j))];
>                                     bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;...
>                                                           bound(i).y((out2in(j)+1):n);...
>                                                           bound(i).y(2:in2out(j))];                              
>                                 end;
> 
>                                 if (~isnan(in2out_xcross(j)))
>                                     bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;in2out_xcross(j)];
>                                     bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;in2out_ycross(j)];
>                                 end;
> 
>                                 new_bound=0; %@@@ Flag initializing a new boundary
> 
>                                 subseg_acc(j) = 1;
>                                 seg_start = j;
>                                 seg_index = j;
480,517c466,474
<                             while (close_bound == 0)
<                                 
<                                 %@@@ Check if last segment and see if can
<                                 %@@@ proceed counter clockwise 
<                             
<                                 if (isempty(find(subseg_acc == 0,1)))
<                                     for k = in2out_gridbox(seg_index):4
<                                         if (domain_inb(k+1) == 1 && crnr_acc(k+1) == 0)
<                                             bound_x = [bound_x;px(k+1)];
<                                             bound_y = [bound_y;py(k+1)];
<                                             crnr_acc(k+1) = 1;
<                                             ending_edge = k;
<                                         else
<                                             close_bound = 1;
<                                             break;
<                                         end;
<                                     end;
<                                 
<                                     if (close_bound == 0)
<                                         for k = 1:(in2out_gridbox(seg_index)-1)
<                                             if (domain_inb(k+1) == 1 && crnr_acc(k+1) == 0)
<                                                 bound_x = [bound_x;px(k+1)];
<                                                 bound_y = [bound_y;py(k+1)];
<                                                 crnr_acc(k+1) = 1;
<                                                 ending_edge = k;
<                                             else
<                                                 close_bound = 1;
<                                                 break;
<                                             end;
<                                         end;
<                                         close_bound = 1;
<                                     end;
<                                 
<                                 else
<                                                                                                     
<                                     curr_seg = seg_index;                           
<                                     kstart = in2out_gridbox(curr_seg);
<                                     start_dist = in2out_gridboxdist(curr_seg);
---
>                                 %@@@ Loop through intersection points till boundary is closed
> 
>                                 while (new_bound == 0)
>  
>                                     %@@@ Find the next closest point where the original polygon crosses the
>                                     %@@@ domain in again
>  
>                                     kstart = in2out_gridbox(seg_index);
>                                     start_dist = in2out_gridboxdist(seg_index);
520,521d476
<                                 
<                                     %@@@ Check all segments
523c478
<                                     for k1 = 1:in2out_count                                        
---
>                                     for k1 = 1:out2in_count                                        
530,531c485,487
<                                 
<                                     if (min_pos == 0)              
---
> 
>                                     if (min_pos == 0)              %@@@ did not find any crossings between in2out 
>                                                                    %@@@ and the end of the box 
539,580c495,516
<                             
<                                     if (subseg_acc(min_pos) == 1)                                                              
<                                         close_bound = 1;          
<                                         ending_edge = in2out_gridbox(curr_seg);
<                                     else 
<                                         kend = out2in_gridbox(min_pos);
<                                         x_mid = [];
<                                         y_mid = [];
< 
<                                         %@@@ If the boundary polygon crosses 
<                                         %@@@ the grid domain along different
<                                         %@@@ domain edges then include the 
<                                         %@@@ common grid domain corner points
< 
<                                         
<                                         if (kstart ~= kend)
<                                             if (kstart < kend)
<                                                 for k1 = kstart:(kend-1)
<                                                     if (domain_inb(k1+1) == 1 ...
<                                                             && crnr_acc(k1+1) == 0)
<                                                         x_mid = [x_mid;px(k1+1)];
<                                                         y_mid = [y_mid;py(k1+1)];
<                                                         crnr_acc(k1+1) = 1;
<                                                     end;
<                                                 end;
<                                             else
<                                                 for k1 = kstart:4
<                                                     if (domain_inb(k1+1) == 1 ...
<                                                             && crnr_acc(k1+1) == 0)
<                                                         x_mid = [x_mid;px(k1+1)];
<                                                         y_mid = [y_mid;py(k1+1)];
<                                                         crnr_acc(k1+1) = 1;
<                                                     end;
<                                                 end;
<                                                 for k1 = 1:(kend-1)
<                                                     if (domain_inb(k1+1) == 1 ...
<                                                             && crnr_acc(k1+1) == 0)
<                                                         x_mid = [x_mid;px(k1+1)];
<                                                         y_mid = [y_mid;py(k1+1)];
<                                                         crnr_acc(k1+1) = 1;
<                                                     end;
<                                                 end;
---
> 
>                                     kend = out2in_gridbox(min_pos);
>                                     x_mid = [];
>                                     y_mid = [];
> 
>                                     %@@@ If the boundary polygon crosses the grid domain along different
>                                     %@@@ domain edges then include the common grid domain corner points
> 
>                                     if (kstart ~= kend)
>                                         if (kstart < kend)
>                                             for k1 = kstart:(kend-1)
>                                                 x_mid = [x_mid;px(k1+1)];
>                                                 y_mid = [y_mid;py(k1+1)];
>                                             end;
>                                         else
>                                             for k1 = kstart:4
>                                                 x_mid = [x_mid;px(k1+1)];
>                                                 y_mid = [y_mid;py(k1+1)];
>                                             end;
>                                             for k1 = 1:(kend-1)
>                                                 x_mid = [x_mid;px(k1+1)];
>                                                 y_mid = [y_mid;py(k1+1)];
583,590c519,549
<                                     
<                                         if (~isempty(x_mid))
<                                             bound_x = [bound_x;x_mid];
<                                             bound_y = [bound_y;y_mid];
<                                         end;
<                                     
<                                         %@@@ Adding the segment
<                                     
---
>                                     end;
> 
>                                     if (~isempty(x_mid))
>                                         bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;x_mid];
>                                         bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;y_mid];
>                                     end;
> 
>                                     %@@@ Check if next crossing from out to in matches starting point of 
>                                     %@@@ new boundary segment. If yes, then close the boundary
> 
>                                     if (min_pos == seg_start)             %@@@ need to close the grid
> 
>                                         bound_ingrid(in_coord).x(end+1) = bound_ingrid(in_coord).x(1);
>                                         bound_ingrid(in_coord).y(end+1) = bound_ingrid(in_coord).y(1);
>                                         bound_count = length(bound_ingrid(in_coord).x);
>                                         bound_ingrid(in_coord).n = bound_count;                                 
>                                         bound_ingrid(in_coord).east = max(bound_ingrid(in_coord).x);
>                                         bound_ingrid(in_coord).west = min(bound_ingrid(in_coord).x);
>                                         bound_ingrid(in_coord).north = max(bound_ingrid(in_coord).y);
>                                         bound_ingrid(in_coord).south = min(bound_ingrid(in_coord).y);
>                                         bound_ingrid(in_coord).height = bound_ingrid(in_coord).north ...
>                                                             - bound_ingrid(in_coord).south;
>                                         bound_ingrid(in_coord).width = bound_ingrid(in_coord).east ...
>                                                             - bound_ingrid(in_coord).west;
>                                         bound_ingrid(in_coord).level = 1;
>                                         in_coord=in_coord+1;            %@@@ increment boundary counter
>                                         new_bound=1;                    %@@@ reset flag to exit the boundary loop
>                                                                         %@@@ and start new boundary
>                     
> 				    else                                %@@@ add segment to the boundary 
> 
592,595c551,554
<                                             bound_x = [bound_x;...
<                                                            out2in_xcross(min_pos)];
<                                             bound_y = [bound_y;...
<                                                            out2in_ycross(min_pos)];
---
>                                             bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;...
>                                                                out2in_xcross(min_pos)];
>                                             bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;...
>                                                                out2in_ycross(min_pos)];
599,604c558,563
<                                             bound_x = [bound_x;...
<                                                            bound(i).x((out2in(min_pos)+1):...
<                                                                         in2out(min_pos))];
<                                             bound_y = [bound_y;...
<                                                            bound(i).y((out2in(min_pos)+1):...
<                                                                         in2out(min_pos))];                                        
---
>                                             bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;...
>                                                                bound(i).x((out2in(min_pos)+1):...
>                                                                                 in2out(min_pos))];
>                                             bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;...
>                                                                bound(i).y((out2in(min_pos)+1):...
>                                                                                 in2out(min_pos))];                                        
606,611c565,570
<                                             bound_x = [bound_x;...
<                                                            bound(i).x((out2in(min_pos)+1):n);...
<                                                            bound(i).x(2:in2out(min_pos))];
<                                             bound_y = [bound_y;...
<                                                            bound(i).y((out2in(min_pos)+1):n);...
<                                                            bound(i).y(2:in2out(min_pos))];      
---
>                                             bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;...
>                                                                bound(i).x((out2in(min_pos)+1):n);...
>                                                                bound(i).x(2:in2out(min_pos))];
>                                             bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;...
>                                                                bound(i).y((out2in(min_pos)+1):n);...
>                                                                bound(i).y(2:in2out(min_pos))];      
615,616c574,577
<                                             bound_x = [bound_x;in2out_xcross(min_pos)];
<                                             bound_y = [bound_y;in2out_ycross(min_pos)];
---
>                                             bound_ingrid(in_coord).x = [bound_ingrid(in_coord).x;...
>                                                                           in2out_xcross(min_pos)];
>                                             bound_ingrid(in_coord).y = [bound_ingrid(in_coord).y;...
>                                                                           in2out_ycross(min_pos)];
619,741c580,592
<                                         subseg_acc(min_pos) = 1;
<                                         ending_edge = in2out_gridbox(min_pos);
<                                         seg_index = min_pos;                             
<                                     end;
<                                     
<                                 end;
<                                 
<                             end;
<                             
<                             %@@@ Need to close the grid;
<                             
<                             if (ending_edge ~= starting_edge)
<                                 if (ending_edge < starting_edge)
<                                     for k = ending_edge:(starting_edge-1)
<                                         if (crnr_acc(k+1) == 0 && ...
<                                                 domain_inb(k+1) == 1)
<                                             bound_x = [bound_x;px(k+1)];
<                                             bound_y = [bound_y;py(k+1)];
<                                             crnr_acc(k+1) = 1;
<                                         end;
<                                     end;
<                                 else
<                                     for k = ending_edge:4
<                                         if (crnr_acc(k+1) == 0 && ...
<                                                 domain_inb(k+1) == 1)
<                                             bound_x = [bound_x;px(k+1)];
<                                             bound_y = [bound_y;py(k+1)];
<                                             crnr_acc(k+1) = 1;
<                                         end;
<                                     end;
<                                     for k =1:(starting_edge-1)
<                                        if (crnr_acc(k+1) == 0 && ...
<                                                domain_inb(k+1) == 1)
<                                             bound_x = [bound_x;px(k+1)];
<                                             bound_y = [bound_y;py(k+1)];
<                                             crnr_acc(k+1) = 1;
<                                         end;
<                                     end;
<                                 end;
<                             end;
<                             
<                             bound_x(end+1) = bound_x(1);
<                             bound_y(end+1) = bound_y(1);
<                             
<                             %@@@ Making sure that the added points do not
<                             %@@@ exceed max. defined seg length
<                             
<                             clear xt1 xt2 yt1 yt2 dist loc x_set y_set;
<                             nsample = length(bound_x);
<                             xt1 = bound_x(1:end-1);
<                             yt1 = bound_y(1:end-1);
<                             xt2 = bound_x(2:end);
<                             yt2 = bound_y(2:end);
<                             
<                             dist = sqrt((xt2-xt1).^2+(yt2-yt1).^2);
<                             loc = find(dist > 2*MAX_SEG_LENGTH);
<                             
<                             if (~isempty(loc))
<                                 x_set = bound_x(1:loc(1));
<                                 y_set = bound_y(1:loc(1));
<                                 nc = length(loc);
<                                 for k = 1:nc
<                                     xp = bound_x(loc(k));
<                                     yp = bound_y(loc(k));
<                                     xn = bound_x(loc(k)+1);
<                                     yn = bound_y(loc(k)+1);
<                                     ns = floor(dist(loc(k))/MAX_SEG_LENGTH)-1;
<                                     if (ns > 0)
<                                         if (xp == xn)
<                                             x_set = [x_set;ones(ns,1)*xp];
<                                             y_set = [y_set;(yp+sign(yn-yp)...
<                                                 *(1:ns)'*MAX_SEG_LENGTH)];
<                                         else
<                                             mth = atan2(yn-yp,xn-xp);
<                                             x_set = [x_set;(xp+[1:ns]'...
<                                                 *MAX_SEG_LENGTH*cos(mth))];
<                                             y_set = [y_set;(yp+[1:ns]'...
<                                                 *MAX_SEG_LENGTH*sin(mth))];
<                                         end;
<                                     end;
<                                     x_set = [x_set;xn];
<                                     y_set = [y_set;yn];
<                                     if k == nc
<                                         if ((loc(k)+1) < nsample)
<                                             x_set = [x_set;bound_x((loc(k)+2:end))];
<                                             y_set = [y_set;bound_y((loc(k)+2:end))];
<                                         end;
<                                     else
<                                         if ((loc(k)+1) < loc(k+1))
<                                             x_set = [x_set;bound_x((loc(k)+2):loc(k+1))];
<                                             y_set = [y_set;bound_y((loc(k)+2):loc(k+1))];
<                                         end;
<                                     end;
<                                 end;
<                             else
<                                 x_set = bound_x;
<                                 y_set = bound_y;
<                             end;
<                             
<                             %@@@ Setting up the boundary polygon
<                             
<                             bound_ingrid(in_coord).x = x_set;
<                             bound_ingrid(in_coord).y = y_set;
<                             bound_count = length(bound_ingrid(in_coord).x);
<                             bound_ingrid(in_coord).n = bound_count;                                 
<                             bound_ingrid(in_coord).east = max(bound_ingrid(in_coord).x);
<                             bound_ingrid(in_coord).west = min(bound_ingrid(in_coord).x);
<                             bound_ingrid(in_coord).north = max(bound_ingrid(in_coord).y);
<                             bound_ingrid(in_coord).south = min(bound_ingrid(in_coord).y);
<                             bound_ingrid(in_coord).height = bound_ingrid(in_coord).north ...
<                                             - bound_ingrid(in_coord).south;
<                             bound_ingrid(in_coord).width = bound_ingrid(in_coord).east ...
<                                             - bound_ingrid(in_coord).west;
<                             bound_ingrid(in_coord).level = 1;
<                                                        
<                             in_coord=in_coord+1;    %@@@ increment boundary 
<                                                     %@@@ counter                                                                       
< 
<                             crnr_acc(1) = crnr_acc(end);
< 
<                         end;         %@@@ corresponds to while loop that 
<                                      %@@@ checks if all sections (subseg_acc) 
<                                      %@@@ have been accounted for. 
---
>                                         seg_index = min_pos;
>                                         subseg_acc(min_pos) = 1;     %@@@ activate flag that segment has been 
>                                                                      %@@@ accounted for
> 
>                                     end; %@@@ end corresponding to check if min_pos == seg_start
> 
>                                 end; %@@@ end of while loop for new_bound. This loop exits when a
>                                      %@@@ a boundary is closed and a new one has to be started
> 
> 			    end;     %@@@ corresponds to if subseg_acc(j) == 0
> 
> 			end;         %@@@ corresponds to while loop that checks if all sections (subseg_acc)
>                                      %@@@ have been accounted for. Loop exits when all accounted for
743,746c594,596
<                     end;             %@@@ corresponds to if in2out_count > 0 
<                                    
<                 end;                 %@@@ corresponds to if statement checking 
<                                      %@@@ if there are boundary points inside 
---
> 		    end;             %@@@ corresponds to if in2out_count > 0 (i.e. there are finite domain crossings)
> 
>                 end;                 %@@@ corresponds to if statement checking if there are boundary points inside 
769,772c619,620
<                 bound_ingrid(in_coord).height = bound_ingrid(in_coord).north ...
<                     - bound_ingrid(in_coord).south;
<                 bound_ingrid(in_coord).width = bound_ingrid(in_coord).east ...
<                     - bound_ingrid(in_coord).west;
---
>                 bound_ingrid(in_coord).height = bound_ingrid(in_coord).north - bound_ingrid(in_coord).south;
>                 bound_ingrid(in_coord).width = bound_ingrid(in_coord).east-bound_ingrid(in_coord).west;
776,777c624
<             end;     %@@@ corresponds to if statement that determines if boundary 
<                      %@@@ lies partially/completely in domain
---
>             end;     %@@@ corresponds to if statement that determines if boundary lies partially/completely in domain
779,780c626
<         end;         %@@@ corresponds to if statement that determines if boundary  
<                      %@@@ lies outside the domain
---
>         end;         %@@@ corresponds to if statement that determines if boundary  lies outside the domain
788,790c634,635
<     if (mod(itmp,5)==0 && itmp_prev ~= itmp && N > 100)
<         fprintf(1,'Completed %d per cent of %d boundaries and found %d internal boundaries \n',...
<             itmp,N,in_coord-1);
---
>     if (mod(itmp,5)==0 & itmp_prev ~= itmp & N > 100)
>         fprintf(1,'Completed %d per cent of %d boundaries and found %d internal boundaries \n',itmp,N,in_coord-1);
